#! /usr/bin/env nix-shell
#! nix-shell -i python3 --pure ../shell.nix

import numpy as np
import ranges

from mutwo import core_events
from mutwo import core_generators
from mutwo import pages_converters
from mutwo import pages_generators

MINIMA_EVENT_COUNT, MAXIMA_EVENT_COUNT = 0, 4


SEGMENT_PAGE_COUNT_RANGE: ranges.Range = ranges.Range(5, 8)

PAGE_COUNT = 100
VOICE_COUNT_LIST = [3, 4, 5]
RANDOM_SEED_LIST = [100, 300, 500]

MINIMA_PERCENTAGE_ENVELOPE_LIST = [
    core_events.Envelope([[0, 1], [0.2, 0.185], [0.4, 0.1], [0.55, 0], [1, 0]]),
    core_events.Envelope([[0, 1], [0.2, 0.5], [0.5, 0.3], [0.7, 0], [1, 0]]),
    core_events.Envelope([[0, 1], [0.2, 0.5], [0.5, 0.3], [1, 0]]),
]


MAXIMA_PERCENTAGE_ENVELOPE_LIST = [
    core_events.Envelope([[0, 0.3], [0.3, 0.9], [0.4, 0.7], [0.6, 0.4], [1, 0]]),
    core_events.Envelope([[0, 0.4], [0.3, 0.95], [0.4, 0.4], [0.6, 0.2], [1, 0]]),
    core_events.Envelope([[0, 0.8], [0.3, 0.3], [0.4, 0], [1, 0]]),
]

CURVE_SHAPE_LIST = [1.4, 1.2, 1.2]

assert len(RANDOM_SEED_LIST) == len(VOICE_COUNT_LIST)
assert len(RANDOM_SEED_LIST) == len(MINIMA_PERCENTAGE_ENVELOPE_LIST)
assert len(RANDOM_SEED_LIST) == len(MAXIMA_PERCENTAGE_ENVELOPE_LIST)


def get_is_short_generator():
    r = np.random.default_rng(134)
    c = core_generators.DynamicChoice(
        [False, True],
        [
            core_events.Envelope([(0, 0.5), (1, 0.5)]),
            core_events.Envelope([(0, 0.15), (1, 0.15)]),
        ],
        random_seed=44,
    )
    # If we have short events, it's better to repeat them for
    # some pages.
    repetition_count = [ranges.Range(1, 2), ranges.Range(3, 4)]
    is_short_list = []
    while len(is_short_list) < PAGE_COUNT:
        position = len(is_short_list) / PAGE_COUNT
        is_short = c.gamble_at(position)
        repetition_count_range = repetition_count[is_short]
        for _ in range(
            r.choice(
                list(
                    range(repetition_count_range.start, repetition_count_range.end + 1)
                )
            )
        ):
            is_short_list.append(is_short)
    return iter(is_short_list)


for (
    curve_shape,
    voice_count,
    random_seed,
    minima_percentage_envelope,
    maxima_percentage_envelope,
) in zip(
    CURVE_SHAPE_LIST,
    VOICE_COUNT_LIST,
    RANDOM_SEED_LIST,
    MINIMA_PERCENTAGE_ENVELOPE_LIST,
    MAXIMA_PERCENTAGE_ENVELOPE_LIST,
):
    minima_duration_generator_seed = random_seed * 2
    maxima_duration_generator_seed = random_seed * 10
    maxima_event_count_envelope_random_seed = random_seed + 87

    minima_duration_generator_short = pages_generators.EnvelopeDistributionRandom(
        pages_converters.constants.MINIMA_DURATION_GENERATOR_OFFSET,
        pages_converters.constants.MINIMA_DURATION_GENERATOR_ENVELOPE,
        random_seed=minima_duration_generator_seed,
    )
    maxima_duration_generator_short = pages_generators.EnvelopeDistributionRandom(
        pages_converters.constants.MAXIMA_DURATION_GENERATOR_OFFSET,
        pages_converters.constants.MAXIMA_DURATION_GENERATOR_ENVELOPE,
        random_seed=maxima_duration_generator_seed,
    )

    minima_duration_generator_long = pages_generators.EnvelopeDistributionRandom(
        pages_converters.constants.MINIMA_DURATION_GENERATOR_OFFSET_LONG,
        pages_converters.constants.MINIMA_DURATION_GENERATOR_ENVELOPE_LONG,
        random_seed=minima_duration_generator_seed,
    )
    maxima_duration_generator_long = pages_generators.EnvelopeDistributionRandom(
        pages_converters.constants.MAXIMA_DURATION_GENERATOR_OFFSET_LONG,
        pages_converters.constants.MAXIMA_DURATION_GENERATOR_ENVELOPE_LONG,
        random_seed=maxima_duration_generator_seed,
    )

    minima_percentage_generator = pages_generators.EnvelopeDistributionRandom(
        0, minima_percentage_envelope, random_seed=random_seed + 32
    )

    maxima_percentage_generator = pages_generators.EnvelopeDistributionRandom(
        0, maxima_percentage_envelope, random_seed=random_seed + 17
    )

    maxima_event_count_envelope = pages_converters.XToMaximaEventCountEnvelope(
        random_seed=maxima_event_count_envelope_random_seed,
        minima_event_count=MINIMA_EVENT_COUNT,
        maxima_event_count=MAXIMA_EVENT_COUNT,
        segment_page_count_range=SEGMENT_PAGE_COUNT_RANGE,
        minima_percentage_generator=minima_percentage_generator,
        maxima_percentage_generator=maxima_percentage_generator,
        curve_shape=curve_shape,
    ).convert(voice_count, PAGE_COUNT)

    page_sequential_event = pages_converters.XToPageSequentialEvent(
        minima_duration_generator_short,
        maxima_duration_generator_short,
        minima_duration_generator_long,
        maxima_duration_generator_long,
        get_is_short_generator=get_is_short_generator,
        random_seed=random_seed,
        minima_event_count=MINIMA_EVENT_COUNT,
        maxima_event_count=MAXIMA_EVENT_COUNT,
        maxima_event_count_envelope=maxima_event_count_envelope,
    ).convert(page_count=PAGE_COUNT, voice_count=voice_count)

    # Start Logging ###################################################
    event_count_list = []
    for page in page_sequential_event:
        event_count_list.append(sum([es.event_count for es in page]))

    print(event_count_list)
    print("")

    global_min_duration = 0
    global_max_duration = 0
    for page in page_sequential_event:
        min_duration = max([e.event_duration_range.start for e in page])
        max_duration = max(
            [
                e.event_duration_range.end
                if e.event_duration_range.end != float("inf")
                else e.event_duration_range.start
                for e in page
            ]
        )
        if not page[0].is_short:
            min_duration *= 60
            max_duration *= 60
        global_min_duration += min_duration
        global_max_duration += max_duration

    print("Min duration:", global_min_duration / 60, "minutes")
    print("Max duration:", global_max_duration / 60, "minutes")

    # End Logging #####################################################

    for paper in ("a4paper", "a5paper"):
        pages_converters.PageSequentialEventToPDF(
            pages_converters.PageToPDF(paper=paper)
        ).convert(page_sequential_event)
